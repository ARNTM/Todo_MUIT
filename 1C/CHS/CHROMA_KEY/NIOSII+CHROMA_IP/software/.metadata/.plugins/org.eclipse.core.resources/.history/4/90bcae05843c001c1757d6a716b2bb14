// RELOJ + TELEPRONTER

#include "key_codes.h"
#include "system.h"
#include "sys/alt_irq.h"
#include <stdio.h>

/* funciones */
void MTL_text (int, int, char *);
void MTL_box (int, int, int, int, short);
void MTL_clean( );
void interval_timer_isr( );
void pushbutton_ISR( );

volatile int key_pressed = KEY2;
volatile int pattern = 0x0000000F;	// patrón para display HEX
volatile int horas, minutos, segundos;

int main(void)
{
	/* Declarar los punteros a registros de I/O como volatile (volatile significa que
 	* que tanto las instrucciones de lectura como las de escritura se pueden utilizar
 	* para acceder a estas posiciones en lugar de realizar accesos a memoria
	*/
	volatile int * interval_timer_ptr = (int *) TIMER_BASE;	// Dirección Temporizador
	// volatile int * red_LED_ptr = (int *) RED_LEDS_BASE; 	// dirección LED rojos
	volatile int * KEY_ptr = (int *) PUSHBUTTONS_BASE; 		// dirección pulsadores KEY
	// volatile int * SW_switch_ptr = (int *) SWITCHES_BASE; 	// dirección SW

	// int HEX_bits = 0x0000000F; 								// patrón para los display HEX
	// int SW_value, KEY_value, delay_count;

	// INTEERRUPCIONES DEL RELOJ
	int counter = 0x2faf080;				// 1/(50 MHz) x (0x2faf080) = 1000 msec = 1sec
	*(interval_timer_ptr + 0x2) = (counter & 0xFFFF);
	*(interval_timer_ptr + 0x3) = (counter >> 16) & 0xFFFF;

	/* comienza el timer y habilita las interrupciones */
	*(interval_timer_ptr + 1) = 0x7;	// STOP = 0, START = 1, CONT = 1, ITO = 1
	alt_irq_register(TIMER_IRQ, NULL, interval_timer_isr);

	// INTERRUPCIONES DE LOS BOTONES
	*(KEY_ptr + 2) = 0xE; 		// Mascara de los pulsadores (bit 0 es reset)
	*(KEY_ptr + 3) = 0;
	alt_irq_register(PUSHBUTTONS_IRQ, NULL, pushbutton_ISR);

	// INTERRUPCIONES DEL SWITCH - TELEPRONTER
	 MTL_box(0, 0, 50*8-1, 30*8-1, 0x0000); // Pantalla en negro MTL_clean

	FILE *fp;
	char buffer[50];
	int nLinea = 0;
	int rFile = 0;
	int fCounter = 0;
	//char ch;

	while(1){
		if (rFile == 0){
			MTL_box(0, 0, 50*8-1, 30*8-1, 0x0000); // Pantalla en negro MTL_clean
			fp = fopen("/mnt/rozipfs/new00.txt", "r");
			if (fp){
				while(fgets(buffer, 50, fp)){
					MTL_text(0, nLinea, buffer);
				}
			}
			fCounter++;
			if (fCounter == 3) fCounter = 0;
			rFile = 1;
		}
	};

}

/****************************************************************************************
 * Subrutina para enviar una cadena de texto a la pantalla MTL
****************************************************************************************/
void MTL_text(int x, int y, char * text_ptr)
{
	int offset;
  	volatile char * character_buffer = (char *)  MTL_CHAR_BUFFER_AVALON_CHAR_BUFFER_SLAVE_BASE;	// MTL character buffer

  	/* asume que la cadena de texto comienza en la primera fila */
	offset = (y << 6) + x;
	while ( *(text_ptr) )
	{
		*(character_buffer + offset) = *(text_ptr);	// escribe en el buffer
		++text_ptr;
		++offset;
	}
}

/****************************************************************************************
 * Dibujar un rectangulo en la pantalla MTL
****************************************************************************************/
void MTL_box(int x1, int y1, int x2, int y2, short pixel_color)
{
	int offset, row, col;
	int SRAM_BASE_SIN_CACHE = (SRAM_BASE + 0x080000000);  //Activando el bit más significativo se elude la cache de datos
  	volatile short * pixel_buffer = (short *) SRAM_BASE_SIN_CACHE;	// MTL pixel buffer

  	/* se asume que las coordenadas del rectangulo son correctas */
	for (row = y1; row <= y2; row++)
	{
		col = x1;
		while (col <= x2)
		{
			offset = (row << 15) + col;
			*(pixel_buffer + offset) = pixel_color;	//procesa mitad direcciones
			++col;
		}
	}
}

/****************************************************************************************
 * Dibujar un rectangulo en la pantalla MTL
****************************************************************************************/
void MTL_clean( ){
	MTL_box(0, 0, 50*8-1, 30*8-1, 0x0000);
}

